/**  bentodev_tests.bento
 *
 *   Tests for Bento web site.
 *
 **/

site pent [=

    test_runner[] test_runners = [ pent_model_tests ]
    

    page(*) tests(params{}) [=
        boolean needs_login = false
        boolean needs_admin = false    
        boolean show_menu = false

        label = "Tests"
    
        [| <h2>Test Results</h2> |]

        /--- run all the tests in the test runner list ---/
        for test_runner tr in test_runners [=                
        
            [| <strong>[= tr.name; =]<strong><ol> |]
            
            tr.run;
        
            for test_result rslt in tr.results [=
                [| <li>Name: [= rslt.name; =]<br>
                      Passed: [= rslt.result; =]<br>
                      log:<ul>
                |]
                for msg in rslt.messages [|
                    <li>[= msg; =]</li>
                |]
                [| </ul></li> |]                
            =]
            [| </ol> |]
        =]
    =]

    test_runner pent_model_tests [=
    
        test_base test_pieces [=
            expected = "ABC"
            
            int num_problems(int n) = n
            
            for piece p in pieces [=
                if (p.protos.count != p.rotations * p.chirality) [=
                    eval(num_problems(: num_problems + 1 :));
                =]
            =]
            
            if (!num_problems) [=
                test_log("all pieces have correct number of protos");
                "A";
            =] else [=
                if (num_problems == 1) [=
                    test_log("one piece has incorrect number of protos");
                =] else [=
                    test_log(num_problems + " pieces have incorrect number of protos");
                =]
                eval(num_problems(: 0 :));
            =]

            for piece p in pieces [=
                if (p.all_positions.count != p.num_positions) [=
                    test_log("piece " + p.id + " num positions should be " + p.num_positions + " but is " + p.all_positions.count);
                    eval(num_problems(: num_problems + 1 :));
                =]
            =]
                
            if (!num_problems) [=
                test_log("all pieces have correct number of positions");
                "B";
            =] else [=
                if (num_problems == 1) [=
                    test_log("one piece has incorrect number of positions");
                =] else [=
                    test_log(num_problems + " pieces have incorrect number of positions");
                =]
                eval(num_problems(: 0 :));
            =]
            
            pent_position pos_accumulator(pent_position pos) = pos
            pent_position full_plus = [ #7E, #FF, #FF, #FF, #FF, #FF, #FF, #7E ]
            pent_position empty_position = [ 0, 0, 0, 0, 0, 0, 0, 0 ]
            pent_position full_position = [ #FF, #FF, #FF, #FF, #FF, #FF, #FF, #FF ]
            
            for piece p in pieces [=
                log("testing piece " + p.id);
                eval(pos_accumulator(: empty_position :));
                for pent_position pos in p.all_positions [=
                    eval(pos_accumulator(: pos_accumulator | pos :));
                =]
                
                if (p.id != PLUS_ID) [=
                    if (pos_accumulator != full_position) [=
                        test_log("all_positions incorrect for piece " + id);
                        eval(num_problems(: num_problems + 1 :));
                    =]
                =] else [=
                    if (pos_accumulator != full_plus) [=
                        test_log("all_positions incorrect for plus");
                        eval(num_problems(: num_problems + 1 :));
                    =]
                =]
            
            =]
            if (!num_problems) [=
                test_log("all pieces have correct all_positions");
                "C";
                eval(num_problems(: 0 :));
            =]
            
        =]
        
        test_base, pent_board test_board_stateless_testers [=
            expected = "ABCDEF"
        
            // empty board
            pent_position z = [ 0, 0, 0, 0, 0, 0, 0, 0 ]
        
            // three squares.  a and b overlap, so do b and c.  a and c do not
            
            pent_position a = [ #C0, #C0, 0, 0, 0, 0, 0, 0 ]
            pent_position b = [ 0, #60, #60, 0, 0, 0, 0, 0 ]
            pent_position c = [ #30, #30, 0, 0, 0, 0, 0, 0 ]

            // test is_empty
            if (is_empty(z)) [=
                "A";
                test_log("is_empty works on empty position");
            =] else [=
                test_log("is_empty failed on empty position");
            =]
            if (!is_empty(a) && !is_empty(b) && !is_empty(c)) [=
                "B";
                test_log("is_empty works on non-empty position");
            =] else [=
                test_log("is_empty failed on non-empty position");
            =]
            
            // test is_hit
            if (is_hit(a, b) && is_hit(b, c)) [=
                "C";
                test_log("is_hit detects overlap");
            =] else [=
                test_log("is_hit failed to detect hit with overlapping positions");
            =]
            if (is_hit(a, a) && is_hit(b, b) && is_hit(c, c)) [=
                "D";
                test_log("is_hit detects hit with self");
            =] else [=
                test_log("is_hit failed to detect hit with self");
            =]
            if (!is_hit(a, z) && !is_hit(b, z) && !is_hit(c, z) && !is_hit(z, z)) [=
                "E";
                test_log("is_hit works (returns false) with empty position");
            =] else [=
                test_log("is_hit detected impossible hit (on empty)");
            =]
            if (!is_hit(a, c)) [=
                "F";
                test_log("is_hit works (returns false) on non-overlapping positions");
            =] else [=
                test_log("is_hit detected nonexistent hit (positions do not overlap)");
            =]
        =]
        
        test_base test_cell_mask_converters [=
            expected = "ABCD"
        
            pent_position empty_mask = [ 0, 0, 0, 0, 0, 0, 0, 0 ]
            pent_position full_mask = [ #FF, #FF, #FF, #FF, #FF, #FF, #FF, #FF ]
            pent_position horizontal_half_mask = [ #FF, #FF, #FF, #FF, 0, 0, 0, 0 ]
            pent_position vertical_half_mask = [ #F0, #F0, #F0, #F0, #F0, #F0, #F0, #F0 ]


            // empty cells to mask
            pent_board empty_cells_board [=
                keep: int[] cells = [ for int i from 0 to 64 [= 0 =] ]
            =]

            if (empty_cells_board.mask == empty_mask) [=
                "A";
                test_log("empty cells correctly converted to mask");
             =] else [=
                test_log("empty cells incorrectly converted to mask: " + empty_cells_board.mask);
             =]
            
            // full cells to mask
            pent_board full_cells_board [=
                keep: int[] cells = [ for int i from 0 to 64 [= (i % 12 + 1) =] ]
            =]

            if (full_cells_board.mask == full_mask) [=
                "B";
                test_log("full cells correctly converted to mask");
             =] else [=
                test_log("full cells incorrectly converted to mask: " + full_cells_board.mask);
             =]
            
            // partial cells to mask
            pent_board horizontal_half_cells_board [=
                keep: int[] cells = [ for int i from 0 to 32 [= (12 - (i % 12)) =] ]
            =]

            pent_board vertical_half_cells_board [=
                keep: int[] cells = [ for int i from 0 to 64 [= 
                                          if (i % 8 < 4) [= (i + 1) =]
                                          else [= 0 =]
                                      =] ]
            =]

            if (horizontal_half_cells_board.mask == horizontal_half_mask) [=
                "C";
                test_log("horizontal half cells correctly converted to mask");
            =] else [=
                test_log("horizontal half cells incorrectly converted to mask: " + horizontal_half_cells_board.mask);
            =]            
            
            if (vertical_half_cells_board.mask == vertical_half_mask) [=
                "D";
                test_log("vertical half cells correctly converted to mask");
            =] else [=
                test_log("vertical half cells incorrectly converted to mask: " + vertical_half_cells_board.mask);
            =]            
            
        

            // empty mask to cells
            
            
            // full mask to cells
            
            
            // partial mask to cells 

        
        =]

        test_base test_board_stateful_testers [=
            expected = "ABC"
        
            // empty board
            pent_board empty_board [=
                keep: pent_position mask = empty_board_mask
            =]
            
            // modified boards
            pent_board board_with_no_openings [=
                keep: int[] cells = [ for int i from 0 to 60 [= 7 =], 0, 0, 0, 0 ]
            =]
            
            pent_board board_with_24_openings [=
                keep: int[] cells = [ for int i from 0 to 52 [= 7 =],
                                      0, 0, 0, 0, 9, 9, 9, 9, 0, 0, 0, 0 ]
            =]

            int num_positions(int n) = n
            
            /--------
            /--- ideal syntax: expression comprehension ---/
            int total_positions = pieces[0].num_positions + for int i = 1 to 12 [= pieces[i].num_positions =]

            /--- not so ideal syntax: dynamic code, but it works ---/              
            int total_positions = [%  "("; for int i from 0 to 11 [= "pieces["; i; "].num_positions + "; =] "pieces[11].num_positions);"; %]              
            ----/
            
            int total_positions [=
                int total(n) = n
                
                for int i = 0 to 12 [=
                    eval(total(: total + pieces[i].num_positions :));
                =]
                
                total;
            =]
                                    
            log("total positions: " + total_positions);
            
            // empty board: every position should be open
            log("computing positions for empty board...");
            eval(num_positions(: 0 :));

            for piece p in pieces [=
                for pent_position pos in p.all_positions [=
                    if (empty_board.is_open(pos)) [=
                        eval(num_positions(: num_positions + 1 :));
                    =]
                =]
            =]
            
            if (num_positions == total_positions) [=
                "A";
                test_log("correct number of open positions on empty board");
            
            =] else [=
                test_log("incorrect number of open positions on empty board: " + num_positions);
            =]

            
            // board with 60 out of 64 cells full: no position should be open
            log("computing positions for board with 4 squares open...");
            eval(num_positions(: 0 :));
            for piece p in pieces [=
                for pent_position pos in p.all_positions [=
                    if (board_with_no_openings.is_open(pos)) [=
                        eval(num_positions(: num_positions + 1 :));
                    =]
                =]
            =]
            
            if (num_positions == 0) [=
                "B";
                test_log("correct number of open positions on board with only four squares open");
            
            =] else [=
                test_log("incorrect number of open positions on board with only four squares open: " + num_positions);
            =]
            
            
            // board with 2 X 4 opening: 24 positions should be open
            // (8 for utah, 4 each for snake, pipe, long_L and C_piece)
            log("computing positions for board with 2 X 4 opening...");
            eval(num_positions(: 0 :));
            for piece p in pieces [=
                for pent_position pos in p.all_positions [=
                    if (board_with_24_openings.is_open(pos)) [=
                        eval(num_positions(: num_positions + 1 :));
                    =]
                =]
            =]
            
            if (num_positions == 24) [=
                "C";
                test_log("correct number of open positions on board with 2 X 4 opening");
            
            =] else [=
                test_log("incorrect number of open positions on board with 2 X 4 opening: " + num_positions);
            =]    
        =]


        test_base test_plays [=
            expected = "ABCD"
            
            play p1 = play(utah, 0)
            pent_position pp1 = [ #80, #C0, #C0, 0, 0, 0, 0, 0 ]
            
            if (p1.piece.name == "Utah") [=
                "A";
                test_log("first play has correct piece");
            =] else [=
                test_log("first play has wrong piece");
            =]
            
            if (p1.position == pp1) [=
                "B";
                test_log("first play has correct position");
            =] else [=
                test_log("first play has wrong position");
            =]
              
            play p2 = play(bar, 63)
            pent_position pp2 = [ 0, 0, 0, 0, 0, 0, 0, #1F ]
        
            if (p2.piece.id == 11) [=
                "C";
                test_log("second play has correct piece");
            =] else [=
                test_log("second play has wrong piece");
            =]
            
            if (p2.position == pp2) [=
                "D";
                test_log("second play has correct position");
            =] else [=
                test_log("second play has wrong position: " + (string) p2.position);
            =]
        =]
    =]
    
    /------ informal tests ------/
    
    page show_all_positions(params{}) [=
    
        int ix = params{"piece"} ? (int) params{"piece"} : 0
        piece p = pieces[ix]
       
        p.name;
        br; br; 
        p.all_positions.count;
        [/ positions: |]
        [| <ol> |]
        
        for pent_position pos in p.all_positions [=
            [| <li> |]
            pos;
            [| </li> |]
        =]
        [| </ol> |]
    =]
    
    show_pos_count [=
        for piece p in pieces [=
            log("checking " + p.name);
            if (p.all_positions.count == p.num_positions) [=
                p.name;
                " is good<br>";
            =]
        =]
    =]
    
    show_a_pos [=
        utah.all_positions[0];
    =]
    
    show_num_pos [=
        for piece p in pieces [=
            "id: ";
            p.id;
            "   num positions: ";
            p.num_positions;
            br;
        =]
    =]
=]
